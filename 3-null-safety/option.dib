#!meta

{"kernelInfo":{"defaultKernelName":"fsharp","items":[{"aliases":[],"languageName":"fsharp","name":"fsharp"}]}}

#!fsharp

#r "nuget: FsToolkit.ErrorHandling, 4.11.0"

#!fsharp

open System
open FsToolkit.ErrorHandling

#!markdown

Let's see an example of the option data type (this is also present in Scala, but not in C#). **An option has an underlying type and can hold a value of that type, or it might not have a value. So the two values could be Some() or None.** The type of m below is Map<string, int>.

#!fsharp

let m = Map[ ("a", 1); ("b", 2) ]
let keyPresent = "a"
let keyAbsent = "c"

#!markdown

The return type of the TryFind function is option<int>.

#!fsharp

let some = m.TryFind(keyPresent)
printfn $"Value of some: {some}"

#!fsharp

let none = m.TryFind(keyAbsent)
printfn $"Value of none: {none}"

#!markdown

Below is how we pattern match on an optional value.

#!fsharp

match none with
| Some(x) -> printfn $"Found key {keyAbsent}"
| None -> printfn $"Not found key {keyAbsent}"

#!markdown

Careful use of Optional values helps us to reduce / eliminate NPEs in the code.

#!markdown

### But you might argue, how is this pattern matching any different than if (something != null) else statement?

#!markdown

First, let's see how to get the value of an option safely.

#!fsharp

let someVal = Option.defaultValue 0 some
printfn $"someVal: {someVal}"

#!markdown

Or in an idiomatic F# way -

#!fsharp

let isomeVal = some |> Option.defaultValue 0
printfn $"isomeVal: {isomeVal}"

#!markdown

Now, let's see how we can use multiple option values together. This is something which is not possible in C#. But `FsToolkit.ErrorHandling` makes it a walk in the park.

#!fsharp

let tryParseInt (str: string) =
    match Int32.TryParse str with
    | (true, i) -> Some i
    | _ -> None

#!fsharp

let addAllSomes = option {
    let! x = tryParseInt "7"
    let! y = tryParseInt "5"
    let! z = tryParseInt "2"
    return x + y + z
}
printfn $"addAllSomes: {addAllSomes}"

#!markdown

And if any of the values is a None, then the entire result is a None.

#!fsharp

let addSomesWithNone = option {
    let! x = tryParseInt "7"
    let! y = tryParseInt "sad"
    let! z = tryParseInt "2"
    return x + y + z
}
printfn $"addSomesWithNone: {addSomesWithNone}"

#!markdown

If you have a list of string values, and you use the above function, you get a list of optional values.

#!fsharp

let listOfSomes =
    ["1"; "2"; "3"]
    |> List.map tryParseInt

printfn $"listOfSomes (which is of type list<option<int>>): {listOfSomes}"

#!markdown

But what if you want an option<list<int>>? Simple, use sequenceOptionM method.

#!fsharp

let someList = 
    ["1"; "2"; "3"]
    |> List.map tryParseInt
    |> List.sequenceOptionM

printfn $"someList (which is of type option<list<int>>): {someList}"
