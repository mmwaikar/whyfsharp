#!meta

{"kernelInfo":{"defaultKernelName":"fsharp","items":[{"aliases":[],"languageName":"fsharp","name":"fsharp"}]}}

#!fsharp

#r "nuget: FsToolkit.ErrorHandling, 4.11.0"

#!fsharp

open System
open FsToolkit.ErrorHandling

#!markdown

Let's see an example of the result data type which can have either of the two values (this is also present in Scala as Either, however in Scala, the left part is an error, whereas the Right part is Success). In F#, the left part is Ok, whereas the right part is Error.

#!fsharp

let divide nr dr =
    if (dr = 0) then Error "Cannot divide by 0."
    else Ok (nr / dr)

#!markdown

The type of the divide function is int -> int -> Result<int, string>.

#!fsharp

let numerator = 4
let denominator = 2

let ok = divide numerator denominator
let error = divide numerator 0

#!markdown

Below is how we pattern match on a result value.

#!fsharp

match ok with
| Ok result -> printfn $"The result of dividing {numerator} with {denominator} is: {result}"
| Error e -> printfn $"Error: {e}"

#!fsharp

match error with
| Ok result -> printfn $"The result of dividing {numerator} with {denominator} is: {result}"
| Error e -> printfn $"Error: {e}"

#!markdown

Careful use of Result values also helps us to reduce / eliminate NPEs in the code. **Not just that, it also helps us communicate the cause of the problems.**

#!markdown

Again, you might say that this pattern matching is not a big deal. We could've used the trusted old if-else statement? So, let's see how we can use multiple result values together. This is something which is not possible in C#. But `FsToolkit.ErrorHandling` makes it a walk in the park.

#!fsharp

let tryParseInt (str: string) =
    match Int32.TryParse str with
    | (true, i) -> Ok i
    | _ -> Error $"Could not parse string {str} to int."

let printResult result =
    match result with
    | Ok i -> printfn $"The result is: {i}"
    | Error e -> printfn $"Error: {e}"

let printResultWithErrors (result: Result<'a list, 'b list>) =
    match result with
    | Ok is -> printfn $"The result is: {is}"
    | Error es -> printfn $"Errors: {es}"

#!fsharp

let addAllOks = result {
    let! x = tryParseInt "7"
    let! y = tryParseInt "5"
    let! z = tryParseInt "2"
    return x + y + z
}
printResult addAllOks

#!fsharp

let addOksWithError = result {
    let! x = tryParseInt "7"
    let! y = tryParseInt "sad"
    let! z = tryParseInt "2"
    return x + y + z
}
printResult addOksWithError

#!markdown

If you have a list of string values, and you use the above function, you get a list of result values.

#!fsharp

let listOfResults =
    ["1"; "2"; "3"]
    |> List.map tryParseInt

printfn $"listOfResults (which is of type list<Result<int, string>>):"
listOfResults |> List.iter printResult

#!markdown

But what if you want a Result<list<int>, string>? Simple, use `sequenceResultM` method.

#!fsharp

let resultList = 
    ["1"; "2"; "3"]
    |> List.map tryParseInt
    |> List.sequenceResultM

printfn $"resultList (which is of type Result<list<int>, string>):"
printResult resultList

#!markdown

But what if one of the values is an error?

#!fsharp

let resultList = 
    ["1"; "foo"; "3"]
    |> List.map tryParseInt
    |> List.sequenceResultM

printfn $"resultList (which is of type Result<list<int>, string>):"
printResult resultList

#!markdown

No, but we don't want that. We want to see all the errors. That's where `sequenceResultA` method comes into picture.
You may have guessed that the `M` stands for `Monad` whereas the `A` stands for `Applicative`.

#!fsharp

let resultListWithAllErrors = 
    ["1"; "foo"; "3"; "bar"]
    |> List.map tryParseInt
    |> List.sequenceResultA

printfn $"resultListWithAllErrors (which is of type Result<list<int>, list<string>>):"
printResultWithErrors resultListWithAllErrors

#!markdown

Another compelling example of how to compose result values is related to validation. It is taken from the [Results](https://learn.microsoft.com/en-us/dotnet/fsharp/language-reference/results) page, but improved with the use of `FsToolkit.ErrorHandling`.

#!fsharp

// Define a simple type which has fields that can be validated
type Request =
    { Name: string
      Email: string }

// Define some logic for what defines a valid name.
//
// Generates a Result which is an Ok if the name validates;
// otherwise, it generates a Result which is an Error.
let validateName req =
    match req.Name with
    | null -> Error "No name found."
    | "" -> Error "Name is empty."
    | "bananas" -> Error "Bananas is not a name."
    | _ -> Ok req

// Similarly, define some email validation logic.
let validateEmail req =
    match req.Email with
    | null -> Error "No email found."
    | "" -> Error "Email is empty."
    | s when s.EndsWith("bananas.com") -> Error "No email from bananas.com is allowed."
    | _ -> Ok req

let validateRequest reqResult =
    reqResult
    |> Result.bind validateName
    |> Result.bind validateEmail

let test() =
    // Now, create a Request and pattern match on the result.
    let req1 = { Name = "Phillip"; Email = "phillip@contoso.biz" }
    let res1 = validateRequest (Ok req1)
    match res1 with
    | Ok req -> printfn $"My request was valid! Name: {req.Name}, Email: {req.Email}"  
    | Error e -> printfn $"Error: {e}"
    // Prints: "My request was valid!  Name: Phillip, Email: phillip@consoto.biz"

    let req2 = { Name = "Phillip"; Email = "phillip@bananas.com" }
    let res2 = validateRequest (Ok req2)
    match res2 with
    | Ok req -> printfn $"My request was valid! Name: {req.Name}, Email: {req.Email}"  
    | Error e -> printfn $"Error: {e}"
    // Prints: "Error: No email from bananas.com is allowed."

    let req3 = { Name = ""; Email = "phillip@bananas.com" }
    let res3 = validateRequest (Ok req3)
    match res3 with
    | Ok req -> printfn $"My request was valid! Name: {req.Name}, Email {req.Email}"
    | Error e -> printfn $"Error: {e}"

test()

#!markdown

Notice that for the 3rd request, even though there were 2 errors, only the first one was reported. This is an example of a short circuiting behavior. So let's see how to get all the errors at once using `FsToolkit's Validation` data type.

#!fsharp

let printValidated (validated: Validation<'a, 'b>) =
    match validated with
    | Ok i -> printfn $"The result is: {i}"
    | Error es -> printfn $"Errors: {es}"

let addResult1 = validation {
    let! x = tryParseInt "1"
    and! y = tryParseInt "str1"
    return x + y
}
printValidated addResult1

let addResult2 = validation {
    let! x = tryParseInt "1"
    and! y = tryParseInt "str2"
    return x + y
}
printValidated addResult2

let combinedResult = 
    validation {
        let! x = addResult1
        and! y = addResult2
        return x + y
    }
printValidated combinedResult
